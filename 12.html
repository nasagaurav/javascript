<script>
	let p1=new Promise(resolve=>setTimeout(()=>resolve("data1"),1000)) //will run after 1 seconds
	let p2=new Promise(resolve=>setTimeout(()=>resolve("data2"),2000)) //will run after 2 seconds
	let p3=new Promise(resolve=>setTimeout(()=>resolve("data3"),3000)) //will run after 3 seconds
	let p4=new Promise(resolve=>setTimeout(()=>resolve("data4"),4000)) //will run after 4 seconds
	let p5=new Promise(resolve=>setTimeout(()=>resolve("data5"),1000)) //will run after 1 seconds
	let p6=new Promise(resolve=>setTimeout(()=>resolve("data6"),1000)) //will run after 1 seconds
	let p7=new Promise(resolve=>setTimeout(()=>resolve("data7"),1000)) //will run after 1 seconds
	let p8=new Promise(resolve=>setTimeout(()=>resolve("data8"),1000)) //will run after 1 seconds
	let p9=new Promise(resolve=>setTimeout(()=>resolve("data9"),1000)) //will run after 1 seconds
	let p10=new Promise(resolve=>setTimeout(()=>resolve("data10"),1000)) //will run after 1 seconds

	// should give output after 1+2+3+4+1+1+1+1+1+1 (seconds)
	// but what it did was calculate highest time in this case (4seconds) was given to entire call
	// and instead of 16 seconds it will give output after 4 seconds in sequesnce i.e 
	// data1
	// data2
	// data3
	// data4
	// data5
	// data6
	// data7
	// data8
	// data9
	// data10

	let a=[p1,p2,p3,p4,p5,p6,p7,p8,p9,p10]
	Promise.allSettled(a)
	.then(d=>console.log(d))
	.catch(e=>console.warn(e))
	.finally(()=>console.log("finally ran"))
</script>




